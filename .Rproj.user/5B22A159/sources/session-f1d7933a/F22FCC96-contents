---
#title: "Homework 1"
output: 
  pdf_document:
    latex_engine: xelatex
    keep_tex: true
#date: "`r Sys.Date()`"
fontsize: 10pt
header-includes:
  - \newcommand{\code}[1]{\colorbox{gray!10}{\texttt{\textcolor{blue!80}{#1}}}}
  - \usepackage{fancyhdr, setspace}
  - \onehalfspacing
  - \pagestyle{fancy}      % Enable fancy page style
  - \fancyhf{}             % Clear header and footer
  - \fancyhead[R]{Homework Six Winter -- 2026}
  - \fancyhead[C]{\underline{\hspace{\textwidth}}}
  - \fancyhead[L]{\noindent STATS 102A Onyambu S.}
  - \fancyfoot[C]{\thepage}
  - \newcommand{\link}[1]{\textbf{\underline{\textcolor{red}{\texttt{#1}}}}}
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
```

## Assignment Submission Instructions

1. **Submit an R Script and/or R Markdown file on Gradescope.**

2. If your functions are defined in Rmarkdown and not in Rscript, follow these requirements:

    * Any chunk that **contains a function definition** must include the chunk option \code{purl = TRUE} as shown below:

       ```{r, eval = FALSE}
       {r, perl = TRUE, echo = FALSE}
       my_fun <- function(x) {
          x + 1
       }
       ```
    * Because functions may be long, include \code{echo = FALSE} chunk option so the function code is not printed in the output.
     * **Test cases must appear in separate chunks** from function definitions.
     * **Do NOT include \code{perl = TRUE}** in chunks that **do not** define functions.

3. If your functions are in Rscript, ensure that the first line of your \code{.Rmd} file (after loading libraries) must source this script using \code{source("123456789\_stats102A\_hw06.R")}. No path should be used when sourcing the script file. Please do not load any libraries in the Rscript.

3. **Submit a PDF file** that displays your results for partial credit.

**Important:** Only use functions learnt in class. DO NOT use anything learned outside of class. Do not load/install packages as this will cause errors. The autograder only has access to tidyverse and base R packages.

**Functions Graded**:

1. \code{cluster()}: Must return a list. Should not have side effects eg printing/cat/plotting etc

2. \code{pqnumber()}: Constructor
3. \code{is\_pqnumber()} : Predicate Function
4. \code{as\_pqnumber()}: Coercion function - Must be a generic function
5. \code{+}: Adding 2 pq numbers
6. \code{-}: Subtracting 2 pq numbers
7. \code{*}: Multiplying 2 pqnumbers
8. \code{as.numeric()}: Coerce to number

\clearpage

## Question One: KMeans Clustering

For this question refer back to lecture 8 notes (functional Programming). 

Write a function \code{cluster(data, k)} that implements the k-means clustering algorithm as described in the lecture notes. Do not use the \code{kmeans} function. The function has two parameters:

-   \code{data} -- The data that needs to be clustered

-   \code{k} -- The number of clusters/groupings

Your function should return a list containing two components, namely:

-   \code{centers} -- A $k\times p$ matrix where $k$ is the number of clusters and $p$ is the dimension of the data. For instance if your data has 2 columns and $k = 3$, then centers will be a $3\times2$ matrix.

-   \code{class}: An integer/numeric vector that indicates which grouping/center an observation belongs to.

Using seed \code{13} to set the random seed, generate a plot that visualizes the distinct groups present in the [\textcolor{blue}{\underline{data provided below}}](raw.githubusercontent.com/oonyambu/ECON430/refs/heads/main/mean_shift.txt)

You can learn a bit more about [\textcolor{red}{kmeans here}](https://oonyambu.github.io/statistics/kmeans.html)

```{r, eval = FALSE}
link <- "https://raw.githubusercontent.com/oonyambu/ECON430/refs/heads/main/mean_shift.txt"
data <- read.table(link, header = TRUE)
set.seed(13L) # For now Must use 13 to get correct graph
cluster(data, 5) #How to call your function
```

```{r, echo=FALSE, include=FALSE}
set.seed(12356)
link <- "https://raw.githubusercontent.com/oonyambu/ECON430/refs/heads/main/mean_shift.txt"
data <- read.table(link, header = TRUE)
plot(data, col=kmeans(data, 5)$cluster)
text(3, 1, "DRAFT", cex=10, srt=-20, col = rgb(1,0,0,0.1))
```

```{r, echo=FALSE,  fig.height=5, fig.width=8}
set.seed(12356)
library(ggplot2)
link <- "https://raw.githubusercontent.com/oonyambu/ECON430/refs/heads/main/mean_shift.txt"
data <- read.table(link, header = TRUE)
cbind(data, col=factor(kmeans(data, 5)$cluster))|>
  ggplot(aes(V1, V2, col = col)) + 
  geom_point()+
  annotate("text", x=3,y=2, label="DRAFT", size=40, angle=-25, alpha=0.2)+
  guides(col = guide_none())
```

# Question Two : Dealing with Large Numbers
We have learned from class that computers have limited memory. And thus are limited in their calculations. What if we are dealing with very huge or very small numbers?

To do calculations using large floating point numbers we define an object called a **(p, q) number** with a list as its base type. The list should have four components. The first one is either the integer \code{+1}, or the integer \code{−1}. It gives the sign of the number. The second and third are \code{p} and \code{q} which are non-negative integers where \code{p} is the number of digits after the decimal point (ie size of mantissa), while \code{q} is the exponent ie \code{q + 1} is the number of digits before the decimal place. Lastly, the fourth component \code{nums} is a vector of \code{p + q + 1} integers between zero and nine. For example, \code{x <- structure(list(sign = 1L, p = 3L, q = 4L, nums = 1:8), class = "pqnumber")} will be a valid (p, q)-number that represents the number \code{87654.321}. 

You might think of a pq number as a double representation as show in class:
$$
r = sign\times\sum_{i=-p}^{i=q} (\text{nums}_i\times 10^i)\\
$$
Thus  with \code{p = 3} and \code{q = 4} with nums \code{1:8} \code{x} has the decimal value:

\code{0.001 + 0.02 + 0.3 + 4 + 50 + 600 + 7000 + 80000 = 87654.321}


This is the double representation for values that are within the computer range:

```{r}
x <- structure(list(sign = -1L, p = 2L, q = 1L, nums = c(4L, 1L, 3L, 0L)), class = "pqnumber")
with(x, sign * sum(nums * 10^seq(-p, q)))
```
Other examples:

\code{x <- structure(list(sign = 1L, p = 3L, q = 4L, nums = c(integer(5), 4L, 1L, 3L)), class = "pqnumber")} is a valid pqnumber that represents the value \code{31400}

\code{x <- structure(list(sign = 1L, p = 2L, q = 0L, nums = c(4L, 1L, 3L)), class = "pqnumber")} is a valid pqnumber that represents the value \code{3.14}

\code{x <- structure(list(sign = -1L, p = 2L, q = 1L, nums = c(4L, 1L, 3L, 0L)), class = "pqnumber")} is a valid pqnumber that represents the value \code{-3.14}


Note that this double representation will not work for numbers greater than \code{.Machine\$double.xmax} therefore its not the correct way to transform your work. This is just to ensure you understand what a \code{pqnumber} is.

```{r, echo=FALSE}

pqnumber <- function(sign, p, q, nums){
  
  if(any(sign != floor(sign), !sign %in% c(-1,1), length(sign)!= 1))
    stop("sign must be either -1L or 1L", call. = FALSE)
  

  if(any(p!=floor(p), p < 0, length(p) != 1))
    stop("p must be a single non-negative integer", call. = FALSE)
  
  if(any(q!=floor(q), q < 0, length(q) != 1))
    stop("q must be a single non-negative integer", call. = FALSE)
  
  if(p + q + 1 != length(nums))
    stop("p + q + 1 must equal length(nums)", call. = FALSE)
  if(any( nums < 0 , nums != floor(nums), nums > 9, na.rm = TRUE))
    stop("nums must contain integers[0-9]", call. = FALSE)
  
  if(sign == 0) nums <- nums*sign
  structure(list(sign = as.integer(sign),
                 p = as.integer(p), 
                 q = as.integer(q),
                 nums = as.integer(nums)),
            class = "pqnumber")
}

drop_zeros <- function(x){
  p <- x$p; q <- x$q; nums <- x$nums
  index <- which(nums>0)
  mx <- max(index, 0)
  mn <- min(index, mx)
  new_p <- max(0, p - mn + 1)
  k=new_q <- max(0, mx - p - 1)
  nums_new <- head(nums, p + new_q+1)|>
    tail(new_q + new_p + 1)
  list(sign=x$sign, p=new_p, q=new_q, nums=nums_new) 
}
is_pqnumber <- function(x) {
  inherits(x, "pqnumber") &&
      !isFALSE(tryCatch(do.call(pqnumber, x), error = \(x)FALSE))
}


format.pqnumber <- function(x, digits = getOption('digits'), scientific = FALSE, ...){
  x <- drop_zeros(x)
  q <- x$q
  nums <- rev(x$nums)
  index <- which.max(nums > 0)
  sgn <- if(x$sign>0)"" else "-"
  if(x$p > digits && index > 5|| q > digits){
    if(q == 0){
      q <- 1 - index
      nums <- tail(nums, 1-index)
    }
    second <- head(nums[-1], digits)
    if(all(second == 0)) nums <- nums[1]
    else {
      nums <- c(nums[1], second[rev(cummax(rev(second))!=0)])
    }
    dec <- if(length(nums)>1)"." else ""
    sprintf("%s%d%s%se%+d", sgn,
            nums[1], dec,
            paste0(head(nums[-1], digits), collapse = ""), q)
  }
  else  {
    nums <- head(nums, max(10,q + min(x$p, abs(digits - q))))
    dec <- if(length(nums) > q+1)"." else ""
    paste0(c(sgn, append(nums, dec, q + 1)), collapse = "")
  }
}

as_pqnumber <- function(x, ...) UseMethod('as_pqnumber')

as_pqnumber.default <- function(x, p = NULL, q = NULL){
  get_num <- function(x){
    v <- strsplit(x, "[.]")[[1]]
    q <- nchar(v[1]) - 1
    p <- if(length(v) == 2) nchar(v[2]) else 0
    nums <- rev(as.integer(unlist(strsplit(v, ""))))
    list(p=p, q=q, nums=nums)
  }

  
  get_num2 <- function(x){
    v <- strsplit(x, "[eE]")[[1]]
    u <- get_num(v[1])
    q <- u$q+as.integer(v[2])
    nums <- u$nums
    n <- length(nums)
    p <- n- q - 1
    if(q < 0) nums <- c(nums, numeric(-q))
    if(p < 0) nums <- c(numeric(-p), nums)
    list(p = max(0, p), q=max(q, 0), nums=nums)
  }
  
  nums <- function(x){
    x <- as.character(x)
    valid <- grepl("^-?\\d+([.]\\d*)?([eE][-+]?\\d+)?$", x)
    if(!valid) stop("Invalid input x", call. = FALSE)
    sign <- if(grepl("^-", x)) -1 else 1
    x <- sub("^-", "", x)
    val <- if(grepl("[eE]", x)) get_num2(x) else get_num(x)
    c(sign=sign, val)
  }
  as_pqnumber.pqnumber(do.call(pqnumber, nums(x)), p, q)
}

as_pqnumber.pqnumber <- function(x, p = NULL, q = NULL){
  if(is.null(q) && is.null(p)) return(x)
  if(is.null(q)) q <- x$q
  if(q < x$q) stop("q cannot be less than ", x$q, call. = FALSE)
  if(q > x$q){
    x$nums <- c(x$nums, numeric(q - x$q))
    x$q <- q
  }
  if(p < x$p) {
    m <- x$p - p 
    x$nums[m + 1] <- round(x$nums[m]) %/% 10 + x$nums[m + 1]
    x$nums <- tail(x$nums, p + x$q + 1)
    x$p <- p
  }
  if(p > x$p){
    x$nums <- c(numeric(p - x$p), x$nums)
    x$p <- p
  }
  x
}
```

<!-- Write a **constructor function**, an appropriate **predicate function**, appropriate **coercion functions**, and a useful **print()** method. -->

\clearpage
\normalsize
## part (a) : constructor \code{pqnumber()} to create a pqnumber

The constructor takes the four arguments: \code{sign}, \code{p}, \code{q}, and \code{nums}. Then checks if the arguments satisfy all requirements for a (p, q) number.

- \code{sign}: an integer \code{-1} or \code{1}.
- \code{p}: A non negative single integer
- \code{q}: A non negative single integer
- \code{nums} : A vector of integers 0-9, of length \code{p + q + 1}

If any of the above conditions is not met, \code{stop()} with an appropriate error message. 

If all the conditions are met, return a (p, q) number object. ie a list with a class attribute \code{"pqnumber"}

\footnotesize
Examples:

```{r, error=TRUE}
pqnumber(2, 3, 4, 1:8) # invalid sign
pqnumber(1, -1, 4, 1:8) # invalid p
pqnumber(-1, 1:2, 4, 1:8) # invalid p
pqnumber(1, 3, -1, 1:8) # invalid q
pqnumber(-1, 3, 4, -1:6) #invalid nums
pqnumber(1, 3, 4, 1:6) #invalid  length of nums
pqnumber(1, 3, 4, 1:8) # passed all test cases
pqnumber(1, 3, 4, integer(8)) # This is a 0 since all nums = 0
```
Ensure that every object within the pqnumber is of type integer:

```{r}
s <- pqnumber(1, 0, 500, c(numeric(500), 1)) # 1e500 very large number.
sapply(s, class)
```

\clearpage
\normalsize
## part (b) : Predicate Function \code{is\_pqnumber(x)}

A predicate is a function that returns a single \code{TRUE} or \code{FALSE}, like \code{is.data.frame()}, or \code{is.factor()}. Your predicate function should be \code{is\_pqnumber()} and should behave as expected. ie ONLY return \code{TRUE} when the object is a VALID \code{pqnumber}. 

Hint: Although we have not tackled error handling, you should be able to use a few functions. eg \code{try} or even \code{tryCatch} if you want. ie, how do you know that the code produced an error? 

```{r}
v <- try(log("a"), silent = TRUE)
inherits(v, 'try-error') # the code produced an error
```
Note that you do not have to follow the hint above. 

Examples:

\footnotesize

```{r, error=TRUE}
is_pqnumber(pqnumber(1, 4, 3, 1:8))
is_pqnumber(1)
is_pqnumber("a")
is_pqnumber(trees)
w <- 123
class(w) <- "pqnumber"
is_pqnumber(w)
u <- structure(list(sign=1.3, p=0, q=1, nums=1), class = 'pqnumber')
is_pqnumber(u)
```

\normalsize
## part (c) Coersion: \code{as\_pqnumber()}


A coercion function forces an object to belong to a class, such as \code{as.factor()} or \code{as\_tibble()}. You will create a \textcolor{red}{GENERIC} coercion function \code{as\_pqnumber()} which will accept a numeric or integer, a valid character, or another pqnumber argument \code{x} and return the appropriate (p, q) number object. Thus you will need at least 3 functions:

```{r, eval = FALSE}
as_pqnumber <- function(x, ...){
  # This is your generic function
}

as_pqnumber.pqnumber <- function(x, p = NULL, q = NULL){
  # To transform a pqnumber into another pqnumber
  # Check the examples below
}


as_pqnumber.default <- function(x, p = NULL, q = NULL){
  # Transforms a double or integer or a valid character.
  # Its the function to fallback  to.
  # use string manipulation on x
}
```


For example, given the decimal number \code{3.14} the function will return a pqnumber with

\code{list(sign = 1, p = 2, q = 0, nums = c(4, 1, 3))}. 

If \code{q} and \code{p} are specified eg \code{p = 3} and \code{q = 4}, the function will return a (p, q) number with

\code{list(sign = 1, p = 3, q = 4, nums = c(0, 4, 1, 3, 0, 0, 0, 0))}.


\footnotesize

```{r, error=TRUE}
as_pqnumber(3.14)
as_pqnumber(3.14, 4, 3)
as_pqnumber("3.14", 3, 4)
as_pqnumber(as_pqnumber(3.14, 3, 2), 4, 5)
as_pqnumber("1e-8")
as_pqnumber("12345e10")
as_pqnumber("12345e-10")
as_pqnumber("-123.45e-10")
as_pqnumber("123a")
```

\normalsize

## part (d) : Printing nicely: \code{print.pqnumber()}

Implement a useful \code{print()} method that should allow users to print a **(p, q) number** in a neat way. 

What are we printing?

Let \code{x <- pqnumber(1, 3, 4, 1:8)}. Then the number becomes:

```{r}
x <- pqnumber(1, 3, 4, 1:8)
cat('[pq] ', rev(append(x$nums, ".", x$p)), "\n", sep = "")
```
Note that there is no computation done. Computation will fail for big numbers thus negating the need for pq-number

Example – Not necessarily printed in this manner

```{r, echo=FALSE}
print.pqnumber <- function(x, ...){
  cat("[pq]", format(x, ...), "\n")
}
```

\footnotesize

```{r}
pqnumber(1, 3, 4, 1:8)
pqnumber(1, 0, 9, rep(9, 10))
pqnumber(1, 500, 0, c(1, numeric(500))) # very small number
pqnumber(1, 0, 500, c(numeric(496), 1:5)) # very huge number
pqnumber(1, 3, 500, c(0,4,1,3, numeric(500))) # 3.14 very many preceding zeros
pqnumber(1, 502, 2, c(numeric(500),4, 1,3, 0, 0)) # 3.14 very many succeeding zeros
as_pqnumber("1e+400")
as_pqnumber("-1e+400")
```

\normalsize
## part (e): Addition and Subtraction: \code{`+.pqnumber`} and \code{`-.pqnumber`}

Write an addition function and a subtraction function. Suppose we have two positive (p, q) number objects \code{x} and \code{y}. Write a function to calculate the sum of \code{x} and \code{y}. Clearly its decimal representation is

$$
x+y=\sum_{s=-p}^q\left(x_s+y_s\right) \times 10^s
$$

but this cannot be used directly because we can have $x_s+y_s>9$. So we need a carry-over algorithm that moves the extra digits in the appropriate way. Same as one would do when adding two large numbers on paper. A subtraction algorithm should have a carry-over algorithm that borrows 10 in the same way as you would do a subtraction with pencil-and-paper. Your functions should work for both positive and negative (p, q) numbers.

```{r, echo=FALSE}
carry <- function(x){
  idx <- which(x > 9)
  if(length(idx)){
    if(max(idx) == (l<-length(x)))  x[l + 1] <- 0
    x[idx +  1] <- x[idx + 1] + x[idx] %/% 10
    x[idx] <- x[idx] %%10
  }
 if(all(x<10)) x else carry(x)
}
borrow <- function(x){
  idx <- which(x < 0)
  if(length(idx)){
     if(max(idx) == (l<-length(x))) x[l + 1] <- 0
     x[idx +  1] <- x[idx + 1] -1
     x[idx] <- x[idx] + 10
  }
   if(all(head(x, -1)>=0)) x else borrow(x)
}

`+.pqnumber` <- function(e1, e2){
  sign <- 1
  e2 <- as_pqnumber(e2)
  p <- pmax(e1$p, e2$p)
  q <- pmax(e1$q, e2$q)
  e1 <- as_pqnumber(e1, p, q)
  e2 <- as_pqnumber(e2, p, q)
  nums <- borrow(carry(e1$sign*e1$nums + e2$sign*e2$nums))
  if(any(nums < 0)){
    nums <- borrow(-nums)
    sign = -1
   }
  pqnumber(sign, p, length(nums)- p - 1, nums)
}

`-.pqnumber` <- function(e1, e2){
  if(missing(e2)) modifyList(e1, list(sign = -e1$sign))
  else e1 + - e2
}
```

\footnotesize

```{r}
a <- pqnumber(1, 0, 20, c(rep(0, 20), 1))
a + 10 - a # 1e20 + 10 - 1e20
b <- pqnumber(-1, 10, 0, c(1, rep(0, 10)))
-a - b + a #  -1e20 -1e-10 + 1e20
a - a
a + a
identical(as_pqnumber(0.1) + as_pqnumber(0.2), as_pqnumber(0.3))
```

\normalsize

## part (f): Multiplication

Write a function which can multiply two pqnumber objects. Think about how you would multiply two large numbers by hand and implement that algorithm in R for two pqnumber objects.

```{r, echo = FALSE}
`*.pqnumber` <- function(e1, e2){
  e2 <- as_pqnumber(e2)
  n <- as_pqnumber(0)
  q <- length(e1$nums)
  for(i in seq_along(e2$num)){
    if(e2$nums[i] ==0)next
    nums <- c(rep(0, i-1), carry(e2$nums[i]*e1$nums))
    n <- n + pqnumber(1, 0, length(nums) - 1, nums)
  }
  p <- e1$p + e2$p
  pqnumber(e1$sign*e2$sign, p, length(n$nums) - p - 1, n$nums)
}
```

```{r}
u <- pqnumber(1, 0, 200, rep(1, 201))
u * u
v <- pqnumber(1, 0, 200, c(numeric(200), 1))
u * v
u + v
u - v
v - u
```

Additional test cases for addition, subtraction and multiplication. Should be included in your pdf
```{r}
x <- pqnumber(1, 0, 300, c(numeric(300), 5))
y <- pqnumber(1, 0, 300, c(numeric(300), 1))
z <- pqnumber(1, 300, 0, c(1, numeric(300)))
x * y
x * z
y * z
x * y * z
x + y
x - y
y - z
z - y
as_pqnumber("1e-1000") * "1e1000"
```
\clearpage
\normalsize

## Part (g): Coerce to \code{numeric()}

```{r, echo=FALSE}
as.double.pqnumber <- function(x){
  x$sign * sum(x$nums * 10 ** seq(-x$p, x$q))
}
```

Using \code{as.double()} as the generic function, write a method that would handle a (p, q) number that is representable in 64bit computer, and convert it to the necessary numeric value. A (p,q) number has the decimal representation defined as follows: 

$$
x=\sum_{s=-p}^q x_s \times 10^s
$$ 
Thus \code{p = 3} and \code{q = 4} with \code{nums = 1:8} has the decimal value

\code{0.001 + 0.002 + 0.3 + 4 + 50 + 600 + 7000 + 80000 = 87654.321}.

\footnotesize

```{r}
options(digits = 10) # to print 10 significant digits
as.numeric(pqnumber(1, 3, 4, 1:8))
as.numeric("4567") # as.numeric still works as intended
```
\normalsize
Using this function, we can confirm the code from part (g) above:

```{r}
x <- pqnumber(1, 0, 300, c(numeric(300), 5))
x1 <- as.numeric(x)
x
x1
y <- pqnumber(1, 0, 300, c(numeric(300), 1))
y1 <- as.numeric(y)
y
y1
z <- pqnumber(1, 300, 0, c(1, numeric(300)))
z1 <- as.numeric(z)
z
z1
```
\normalsize
Compare below:

```{r}
x * y # pqnumber computation
x1 * y1 # numerical counterpart. Not possible in 64bit computer
x * z  # pqnumber computation
x1 * z1 # numerical counterpart
y * z  # pqnumber computation
y1 * z1  # numerical counterpart
x * y * z  # pqnumber computation
x1 * y1 * z1  # numerical counterpart
```
\normalsize
Why did the above produce \code{Inf} instead of \code{5e+300} which is representable in R? Well R is using PEMDAS and doing multiplication from left to right. \code{x1 * y1} is already Infinity. Thus not able to simplify. To obtain the correct result, change the order:


```{r}
x1 * z1 * y1  # numerical counterpart
x + y # pqnumber computation
x1 + y1  # numerical counterpart
x - y # pqnumber computation
x1 - y1  # numerical counterpart
y - z # pqnumber computation
y1 - z1  # numerical counterpart
z - y # pqnumber computation
z1 - y1 # numerical counterpart
```

